{"ast":null,"code":"import _ from 'lodash';\nimport { Component } from 'react';\nexport class MountableComponent extends Component {\n  constructor(...args) {\n    super(...args);\n    this._unmounted = true;\n    this.op = {\n      log: (value1, value2, value3, value4, value5) => {\n        if (value1 === undefined) {\n          console.log(this.__proto__.constructor.name, this.state);\n        } else if (value2 === undefined) {\n          console.log(this.__proto__.constructor.name, value1);\n        } else if (value3 === undefined) {\n          console.log(this.__proto__.constructor.name, value1, value2);\n        } else if (value4 === undefined) {\n          console.log(this.__proto__.constructor.name, value1, value2, value3);\n        } else if (value5 === undefined) {\n          console.log(this.__proto__.constructor.name, value1, value2, value3, value4);\n        } else {\n          console.warn(this.__proto__.constructor.name, 'MAX_ARGS', value1, value2, value3, value4, value5);\n        }\n      },\n\n      /**\n       * Performs a deep comparison between two values to determine if they are equivalent.\n       * @param firstValue The first value to compare.\n       * @param secondValue The second value to compare.\n       */\n      equal: (firstValue, secondValue) => {\n        return _.isEqual(firstValue, secondValue);\n      },\n\n      /**\n       * Creates a deep clone of value.\n       *\n       * Note: This method is loosely based on the structured clone algorithm and supports cloning arrays,\n       * array buffers, booleans, date objects, maps, numbers, Object objects, regexes, sets, strings, symbols,\n       * and typed arrays. The own enumerable properties of arguments objects are cloned as plain objects. An empty\n       * object is returned for uncloneable values such as error objects, functions, DOM nodes, and WeakMaps.\n       *\n       * @param value The value to recursively clone.\n       * @return Returns the deep cloned value.\n       */\n      cloneDeep: value => {\n        return _.cloneDeep(value);\n      },\n\n      /**\n       * Helper method for getting values from object in a safe way.\n       * @param {Object} object The object to query.\n       * @param {string[]|string} keyPath The path of the property to get.\n       */\n      get: (object, keyPath) => {\n        if (_.isString(keyPath) || _.isArray(keyPath)) {\n          return _.get(object, keyPath);\n        } else {\n          throw new Error(\"Illegal argument keyPath: \".concat(keyPath, \" | object: \").concat(object));\n        }\n      },\n\n      /**\n       * Helper method for getting/setting state.input.active, can be used to control an edit-mode or the like!\n       */\n      inputActive: value => {\n        return this.op.input('active', value);\n      },\n\n      /**\n       * Helper method for toggling the state.input.active value.\n       */\n      inputActiveToggle: () => {\n        return this.op.input('active', !!!this.op.input('active'));\n      },\n\n      /**\n       * Helper method for getting/setting state.input values, same API as\n       * this.op.state() but keyPath is auto-prefixed with 'input'.\n       */\n      input: (keyPath, value) => {\n        keyPath = keyPath ? 'input.' + keyPath : 'input';\n        return this.op.state(keyPath, value);\n      },\n\n      /**\n       * Helper method for getting state.input-values, or return defaultValue if state.input-value is undefined.\n       */\n      inputOr: (keyPath, defaultValue) => {\n        const stateValue = this.op.input(keyPath);\n\n        if (stateValue !== undefined) {\n          return stateValue;\n        } else {\n          return defaultValue;\n        }\n      },\n\n      /**\n       * Helper method for getting state.input-values, or return null for all falsy-values.\n       */\n      inputOrNull: keyPath => {\n        const stateValue = this.op.input(keyPath);\n\n        if (stateValue === undefined || !!stateValue) {\n          // if undefined or truthy we return stateValue\n          return stateValue;\n        } else {\n          // if NOT undefined and falsy we return null\n          return null;\n        }\n      },\n\n      /**\n       * Helper method for getting/setting state.dialog values, same API as\n       * this.op.state() but keyPath is auto-prefixed with 'dialog'.\n       * This method also supports single object-argument to set entire object of state.dialog\n       */\n      dialog: (keyPath, value) => {\n        if (_.isObject(keyPath)) {\n          value = keyPath;\n          keyPath = '';\n        }\n\n        keyPath = keyPath ? 'dialog.' + keyPath : 'dialog';\n        return this.op.state(keyPath, value);\n      },\n\n      /**\n       * Helper method for getting and setting values on state in a safe way.\n       * @param {string[]|string} keyPath The path of the property to get or set.\n       * @param {object} [value] The new value of the property, if supplied.\n       */\n      state: (keyPath, value) => {\n        if (value === undefined) {\n          // Getter functionality\n          if (_.isString(keyPath) || _.isArray(keyPath)) {\n            return _.get(this.state, keyPath);\n          } else {\n            throw new Error(\"Illegal argument keyPath: \".concat(keyPath));\n          }\n        } else {\n          // Setter functionality\n          if (_.isString(keyPath) || _.isArray(keyPath)) {\n            if (!this._unmounted) {\n              // TODO do we need to optimise this code?\n              this.setState((state, _props) => {\n                const newState = _.cloneDeep(state); // spread-operator results in corrupted state\n\n\n                _.set(newState, keyPath, value);\n\n                return newState;\n              });\n            } else {// // Only log in dev\n              // if (process.env.NODE_ENV !== 'production') {\n              //   this.op.log('BLOCKED op.state-setter when _unmounted = true')\n              // }\n            }\n          } else {\n            throw new Error(\"Illegal argument keyPath: \".concat(keyPath));\n          }\n        }\n      },\n\n      /**\n       * Helper method for getting state-values, or return defaultValue if state-value is undefined.\n       */\n      stateOr: (keyPath, defaultValue) => {\n        const stateValue = this.op.state(keyPath);\n\n        if (stateValue !== undefined) {\n          return stateValue;\n        } else {\n          return defaultValue;\n        }\n      },\n\n      /**\n       * Helper method for getting values from props in a safe way.\n       * @param {string[]|string} keyPath The path of the property to get.\n       */\n      props: keyPath => {\n        if (_.isString(keyPath) || _.isArray(keyPath)) {\n          return _.get(this.props, keyPath);\n        } else {\n          throw new Error(\"Illegal argument keyPath: \".concat(keyPath));\n        }\n      }\n    };\n    this.input = {\n      /**\n       * Helper method for getting values on state in a safe way.\n       * @param {string[]|string} keyPath The path of the property to get or set.\n       * @returns {any} Returns value that keyPath references.\n       */\n      stateGet: keyPath => {\n        if (_.isString(keyPath) || _.isArray(keyPath)) {\n          return _.get(this.state, keyPath);\n        } else {\n          throw new Error(\"Illegal argument keyPath: \".concat(keyPath));\n        }\n      },\n\n      /**\n       * Helper method for setting values on state in a safe way.\n       * @param {string[]|string} keyPath The path of the property to get or set.\n       * @param {any} value The new value of the property, if supplied.\n       */\n      stateSet: (keyPath, value) => {\n        // Setter functionality\n        if (_.isString(keyPath) || _.isArray(keyPath)) {\n          if (!this._unmounted) {\n            // TODO do we need to optimise this code?\n            this.setState((state, _props) => {\n              const newState = _.cloneDeep(state); // spread-operator results in corrupted state\n\n\n              _.set(newState, keyPath, value);\n\n              return newState;\n            });\n          } else {\n            // Only log in dev\n            if (process.env.NODE_ENV !== 'production') {\n              this.op.log('BLOCKED input.stateSet() when _unmounted = true');\n            }\n          }\n        } else {\n          throw new Error(\"Illegal argument keyPath: \".concat(keyPath));\n        }\n      },\n\n      /**\n       * Helper method for getting state.input values, or return defaultValue if state.input-value is undefined.\n       * @param {string[]|string} keyPath The path of the property to get or set.\n       * @param {any} defaultValue The default value that will be returned if keyPath points to an undefined object.\n       * @returns {any} Returns value that keyPath references, if value referenced by keyPath is undefined defaultValue will be returned.\n       */\n      get: (keyPath, defaultValue) => {\n        keyPath = keyPath ? 'input.' + keyPath : 'input';\n        const stateValue = this.input.stateGet(keyPath);\n\n        if (stateValue !== undefined) {\n          return stateValue;\n        } else {\n          return defaultValue;\n        }\n      },\n\n      /**\n       * Helper method for setting state.input values, same API as this.op.stateSet() but keyPath is auto-prefixed with 'input'.\n       * @param {string[]|string} keyPath The path of the property to get or set.\n       * @param {any} value The new value of the property, if supplied.\n       */\n      set: (keyPath, value) => {\n        keyPath = keyPath ? 'input.' + keyPath : 'input';\n        return this.input.stateSet(keyPath, value);\n      },\n\n      /**\n       * Helper method for casting a value to an Integer.\n       * @param {any} intValue The value that will be converted to an Integer.\n       * @param {number} defaultValue The default value that will be returned if intValue can not be converted to an Integer.\n       * @returns {number|undefined} Returns a number, returns undefined if intValue and defaultValue is undefined.\n       */\n      castInt: (intValue, defaultValue) => {\n        const parsedInt = parseInt(intValue, 10);\n\n        if (isNaN(parsedInt)) {\n          const parsedDefaultValue = parseInt(defaultValue, 10);\n\n          if (isNaN(parsedDefaultValue)) {\n            return undefined;\n          } else {\n            return parsedDefaultValue;\n          }\n        } else {\n          return parsedInt;\n        }\n      },\n\n      /**\n       * Helper method for getting state.input-values as Integers, or return defaultValue as Integer if state.input-value is undefined.\n       * @param {string[]|string} keyPath The path of the property to get or set.\n       * @param {any} defaultValue The default value that will be returned if keyPath points to an undefined object.\n       * @returns {number|undefined} Returns a number, returns undefined if keyPath-value and defaultValue can not be converted to an Integer.\n       */\n      int: (keyPath, defaultValue) => {\n        return this.input.castInt(this.input.get(keyPath), defaultValue);\n      },\n\n      /**\n       * Helper method for casting a value to a Float.\n       * @param {any} floatValue The value that will be converted to a Float.\n       * @param {number} defaultValue The default value that will be returned if floatValue can not be converted to a Float.\n       * @returns {number|undefined} Returns a number, returns undefined if floatValue and defaultValue can not be converted to a Float.\n       */\n      castFloat: (floatValue, defaultValue) => {\n        if (typeof floatValue === 'number') {\n          return floatValue;\n        }\n\n        const parsedFloat = parseFloat(floatValue);\n\n        if (isNaN(parsedFloat)) {\n          if (typeof defaultValue === 'number') {\n            return defaultValue;\n          }\n\n          const parsedDefaultValue = parseFloat(defaultValue);\n\n          if (isNaN(parsedDefaultValue)) {\n            return undefined;\n          } else {\n            return parsedDefaultValue;\n          }\n        } else {\n          return parsedFloat;\n        }\n      },\n\n      /**\n       * Helper method for getting state.input-values as Floats, or return defaultValue as Float if state.input-value is undefined.\n       * @param {string[]|string} keyPath The path of the property to get or set.\n       * @param {any} defaultValue The default value that will be returned if keyPath points to an undefined object.\n       * @returns {number|undefined} Returns a number, returns undefined if keyPath-value and defaultValue can not be converted to a Float.\n       */\n      float: (keyPath, defaultValue) => {\n        return this.input.castFloat(this.input.get(keyPath), defaultValue);\n      },\n\n      /**\n       * Helper method for casting a value to a String.\n       * @param {any} stringValue The value that will be converted to a String.\n       * @param {any} defaultValue The default value that will be returned if stringValue can not be converted to a String.\n       * @returns {string|null|undefined} Returns a string or null, returns undefined if stringValue and defaultValue is undefined.\n       */\n      castString: (stringValue, defaultValue) => {\n        if (typeof stringValue === 'string') {\n          return stringValue;\n        } else if (stringValue === undefined) {\n          if (typeof defaultValue === 'string') {\n            return defaultValue;\n          } else if (defaultValue === undefined) {\n            return undefined;\n          } else if (defaultValue === null) {\n            return null;\n          } else {\n            return String(defaultValue);\n          }\n        } else if (stringValue === null) {\n          return null;\n        } else {\n          return String(stringValue);\n        }\n      },\n\n      /**\n       * Helper method for getting state.input-values as Strings, or return defaultValue as String if state.input-value is undefined.\n       * @param {string[]|string} keyPath The path of the property to get or set.\n       * @param {any} defaultValue The default value that will be returned if keyPath points to an undefined object.\n       * @returns {string|null|undefined} Returns a string or null, returns undefined if keyPath points to undefined object and defaultValue is undefined.\n       */\n      string: (keyPath, defaultValue) => {\n        return this.input.castString(this.input.get(keyPath), defaultValue);\n      }\n    };\n  }\n\n  componentDidMount() {\n    this._unmounted = false; // console.log('MountableComponent._unmounted:', this._unmounted)\n  }\n  /**\n   * https://reactjs.org/docs/react-component.html#componentwillunmount\n   * componentWillUnmount() is invoked immediately before a component is unmounted and destroyed.\n   * Perform any necessary cleanup in this method, such as invalidating timers,\n   * canceling network requests, or cleaning up any subscriptions that were created in componentDidMount().\n   *\n   * You should not call setState() in componentWillUnmount() because the component will never be re-rendered.\n   * Once a component instance is unmounted, it will never be mounted again.\n   */\n\n\n  componentWillUnmount() {\n    this._unmounted = true; // console.log('MountableComponent._unmounted:', this._unmounted)\n  }\n\n}","map":{"version":3,"sources":["/Users/maxmagnusson/Desktop/landing-react/src/_components/MountableComponent.jsx"],"names":["_","Component","MountableComponent","_unmounted","op","log","value1","value2","value3","value4","value5","undefined","console","__proto__","constructor","name","state","warn","equal","firstValue","secondValue","isEqual","cloneDeep","value","get","object","keyPath","isString","isArray","Error","inputActive","input","inputActiveToggle","inputOr","defaultValue","stateValue","inputOrNull","dialog","isObject","setState","_props","newState","set","stateOr","props","stateGet","stateSet","process","env","NODE_ENV","castInt","intValue","parsedInt","parseInt","isNaN","parsedDefaultValue","int","castFloat","floatValue","parsedFloat","parseFloat","float","castString","stringValue","String","string","componentDidMount","componentWillUnmount"],"mappings":"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","sourcesContent":["import _ from 'lodash'\nimport { Component } from 'react'\n\nexport class MountableComponent extends Component {\n  _unmounted = true\n\n  op = {\n    log: (value1, value2, value3, value4, value5) => {\n      if (value1 === undefined) {\n        console.log(this.__proto__.constructor.name, this.state)\n      } else if (value2 === undefined) {\n        console.log(this.__proto__.constructor.name, value1)\n      } else if (value3 === undefined) {\n        console.log(this.__proto__.constructor.name, value1, value2)\n      } else if (value4 === undefined) {\n        console.log(this.__proto__.constructor.name, value1, value2, value3)\n      } else if (value5 === undefined) {\n        console.log(\n          this.__proto__.constructor.name,\n          value1,\n          value2,\n          value3,\n          value4\n        )\n      } else {\n        console.warn(\n          this.__proto__.constructor.name,\n          'MAX_ARGS',\n          value1,\n          value2,\n          value3,\n          value4,\n          value5\n        )\n      }\n    },\n    /**\n     * Performs a deep comparison between two values to determine if they are equivalent.\n     * @param firstValue The first value to compare.\n     * @param secondValue The second value to compare.\n     */\n    equal: (firstValue, secondValue) => {\n      return _.isEqual(firstValue, secondValue)\n    },\n    /**\n     * Creates a deep clone of value.\n     *\n     * Note: This method is loosely based on the structured clone algorithm and supports cloning arrays,\n     * array buffers, booleans, date objects, maps, numbers, Object objects, regexes, sets, strings, symbols,\n     * and typed arrays. The own enumerable properties of arguments objects are cloned as plain objects. An empty\n     * object is returned for uncloneable values such as error objects, functions, DOM nodes, and WeakMaps.\n     *\n     * @param value The value to recursively clone.\n     * @return Returns the deep cloned value.\n     */\n    cloneDeep: value => {\n      return _.cloneDeep(value)\n    },\n    /**\n     * Helper method for getting values from object in a safe way.\n     * @param {Object} object The object to query.\n     * @param {string[]|string} keyPath The path of the property to get.\n     */\n    get: (object, keyPath) => {\n      if (_.isString(keyPath) || _.isArray(keyPath)) {\n        return _.get(object, keyPath)\n      } else {\n        throw new Error(\n          `Illegal argument keyPath: ${keyPath} | object: ${object}`\n        )\n      }\n    },\n    /**\n     * Helper method for getting/setting state.input.active, can be used to control an edit-mode or the like!\n     */\n    inputActive: value => {\n      return this.op.input('active', value)\n    },\n    /**\n     * Helper method for toggling the state.input.active value.\n     */\n    inputActiveToggle: () => {\n      return this.op.input('active', !!!this.op.input('active'))\n    },\n    /**\n     * Helper method for getting/setting state.input values, same API as\n     * this.op.state() but keyPath is auto-prefixed with 'input'.\n     */\n    input: (keyPath, value) => {\n      keyPath = keyPath ? 'input.' + keyPath : 'input'\n      return this.op.state(keyPath, value)\n    },\n    /**\n     * Helper method for getting state.input-values, or return defaultValue if state.input-value is undefined.\n     */\n    inputOr: (keyPath, defaultValue) => {\n      const stateValue = this.op.input(keyPath)\n      if (stateValue !== undefined) {\n        return stateValue\n      } else {\n        return defaultValue\n      }\n    },\n    /**\n     * Helper method for getting state.input-values, or return null for all falsy-values.\n     */\n    inputOrNull: keyPath => {\n      const stateValue = this.op.input(keyPath)\n      if (stateValue === undefined || !!stateValue) {\n        // if undefined or truthy we return stateValue\n        return stateValue\n      } else {\n        // if NOT undefined and falsy we return null\n        return null\n      }\n    },\n    /**\n     * Helper method for getting/setting state.dialog values, same API as\n     * this.op.state() but keyPath is auto-prefixed with 'dialog'.\n     * This method also supports single object-argument to set entire object of state.dialog\n     */\n    dialog: (keyPath, value) => {\n      if (_.isObject(keyPath)) {\n        value = keyPath\n        keyPath = ''\n      }\n      keyPath = keyPath ? 'dialog.' + keyPath : 'dialog'\n      return this.op.state(keyPath, value)\n    },\n    /**\n     * Helper method for getting and setting values on state in a safe way.\n     * @param {string[]|string} keyPath The path of the property to get or set.\n     * @param {object} [value] The new value of the property, if supplied.\n     */\n    state: (keyPath, value) => {\n      if (value === undefined) {\n        // Getter functionality\n        if (_.isString(keyPath) || _.isArray(keyPath)) {\n          return _.get(this.state, keyPath)\n        } else {\n          throw new Error(`Illegal argument keyPath: ${keyPath}`)\n        }\n      } else {\n        // Setter functionality\n        if (_.isString(keyPath) || _.isArray(keyPath)) {\n          if (!this._unmounted) {\n            // TODO do we need to optimise this code?\n            this.setState((state, _props) => {\n              const newState = _.cloneDeep(state) // spread-operator results in corrupted state\n              _.set(newState, keyPath, value)\n              return newState\n            })\n          } else {\n            // // Only log in dev\n            // if (process.env.NODE_ENV !== 'production') {\n            //   this.op.log('BLOCKED op.state-setter when _unmounted = true')\n            // }\n          }\n        } else {\n          throw new Error(`Illegal argument keyPath: ${keyPath}`)\n        }\n      }\n    },\n    /**\n     * Helper method for getting state-values, or return defaultValue if state-value is undefined.\n     */\n    stateOr: (keyPath, defaultValue) => {\n      const stateValue = this.op.state(keyPath)\n      if (stateValue !== undefined) {\n        return stateValue\n      } else {\n        return defaultValue\n      }\n    },\n    /**\n     * Helper method for getting values from props in a safe way.\n     * @param {string[]|string} keyPath The path of the property to get.\n     */\n    props: keyPath => {\n      if (_.isString(keyPath) || _.isArray(keyPath)) {\n        return _.get(this.props, keyPath)\n      } else {\n        throw new Error(`Illegal argument keyPath: ${keyPath}`)\n      }\n    }\n  }\n\n  input = {\n    /**\n     * Helper method for getting values on state in a safe way.\n     * @param {string[]|string} keyPath The path of the property to get or set.\n     * @returns {any} Returns value that keyPath references.\n     */\n    stateGet: keyPath => {\n      if (_.isString(keyPath) || _.isArray(keyPath)) {\n        return _.get(this.state, keyPath)\n      } else {\n        throw new Error(`Illegal argument keyPath: ${keyPath}`)\n      }\n    },\n    /**\n     * Helper method for setting values on state in a safe way.\n     * @param {string[]|string} keyPath The path of the property to get or set.\n     * @param {any} value The new value of the property, if supplied.\n     */\n    stateSet: (keyPath, value) => {\n      // Setter functionality\n      if (_.isString(keyPath) || _.isArray(keyPath)) {\n        if (!this._unmounted) {\n          // TODO do we need to optimise this code?\n          this.setState((state, _props) => {\n            const newState = _.cloneDeep(state) // spread-operator results in corrupted state\n            _.set(newState, keyPath, value)\n            return newState\n          })\n        } else {\n          // Only log in dev\n          if (process.env.NODE_ENV !== 'production') {\n            this.op.log('BLOCKED input.stateSet() when _unmounted = true')\n          }\n        }\n      } else {\n        throw new Error(`Illegal argument keyPath: ${keyPath}`)\n      }\n    },\n    /**\n     * Helper method for getting state.input values, or return defaultValue if state.input-value is undefined.\n     * @param {string[]|string} keyPath The path of the property to get or set.\n     * @param {any} defaultValue The default value that will be returned if keyPath points to an undefined object.\n     * @returns {any} Returns value that keyPath references, if value referenced by keyPath is undefined defaultValue will be returned.\n     */\n    get: (keyPath, defaultValue) => {\n      keyPath = keyPath ? 'input.' + keyPath : 'input'\n      const stateValue = this.input.stateGet(keyPath)\n      if (stateValue !== undefined) {\n        return stateValue\n      } else {\n        return defaultValue\n      }\n    },\n    /**\n     * Helper method for setting state.input values, same API as this.op.stateSet() but keyPath is auto-prefixed with 'input'.\n     * @param {string[]|string} keyPath The path of the property to get or set.\n     * @param {any} value The new value of the property, if supplied.\n     */\n    set: (keyPath, value) => {\n      keyPath = keyPath ? 'input.' + keyPath : 'input'\n      return this.input.stateSet(keyPath, value)\n    },\n    /**\n     * Helper method for casting a value to an Integer.\n     * @param {any} intValue The value that will be converted to an Integer.\n     * @param {number} defaultValue The default value that will be returned if intValue can not be converted to an Integer.\n     * @returns {number|undefined} Returns a number, returns undefined if intValue and defaultValue is undefined.\n     */\n    castInt: (intValue, defaultValue) => {\n      const parsedInt = parseInt(intValue, 10)\n      if (isNaN(parsedInt)) {\n        const parsedDefaultValue = parseInt(defaultValue, 10)\n        if (isNaN(parsedDefaultValue)) {\n          return undefined\n        } else {\n          return parsedDefaultValue\n        }\n      } else {\n        return parsedInt\n      }\n    },\n    /**\n     * Helper method for getting state.input-values as Integers, or return defaultValue as Integer if state.input-value is undefined.\n     * @param {string[]|string} keyPath The path of the property to get or set.\n     * @param {any} defaultValue The default value that will be returned if keyPath points to an undefined object.\n     * @returns {number|undefined} Returns a number, returns undefined if keyPath-value and defaultValue can not be converted to an Integer.\n     */\n    int: (keyPath, defaultValue) => {\n      return this.input.castInt(this.input.get(keyPath), defaultValue)\n    },\n    /**\n     * Helper method for casting a value to a Float.\n     * @param {any} floatValue The value that will be converted to a Float.\n     * @param {number} defaultValue The default value that will be returned if floatValue can not be converted to a Float.\n     * @returns {number|undefined} Returns a number, returns undefined if floatValue and defaultValue can not be converted to a Float.\n     */\n    castFloat: (floatValue, defaultValue) => {\n      if (typeof floatValue === 'number') {\n        return floatValue\n      }\n      const parsedFloat = parseFloat(floatValue)\n      if (isNaN(parsedFloat)) {\n        if (typeof defaultValue === 'number') {\n          return defaultValue\n        }\n        const parsedDefaultValue = parseFloat(defaultValue)\n        if (isNaN(parsedDefaultValue)) {\n          return undefined\n        } else {\n          return parsedDefaultValue\n        }\n      } else {\n        return parsedFloat\n      }\n    },\n    /**\n     * Helper method for getting state.input-values as Floats, or return defaultValue as Float if state.input-value is undefined.\n     * @param {string[]|string} keyPath The path of the property to get or set.\n     * @param {any} defaultValue The default value that will be returned if keyPath points to an undefined object.\n     * @returns {number|undefined} Returns a number, returns undefined if keyPath-value and defaultValue can not be converted to a Float.\n     */\n    float: (keyPath, defaultValue) => {\n      return this.input.castFloat(this.input.get(keyPath), defaultValue)\n    },\n    /**\n     * Helper method for casting a value to a String.\n     * @param {any} stringValue The value that will be converted to a String.\n     * @param {any} defaultValue The default value that will be returned if stringValue can not be converted to a String.\n     * @returns {string|null|undefined} Returns a string or null, returns undefined if stringValue and defaultValue is undefined.\n     */\n    castString: (stringValue, defaultValue) => {\n      if (typeof stringValue === 'string') {\n        return stringValue\n      } else if (stringValue === undefined) {\n        if (typeof defaultValue === 'string') {\n          return defaultValue\n        } else if (defaultValue === undefined) {\n          return undefined\n        } else if (defaultValue === null) {\n          return null\n        } else {\n          return String(defaultValue)\n        }\n      } else if (stringValue === null) {\n        return null\n      } else {\n        return String(stringValue)\n      }\n    },\n    /**\n     * Helper method for getting state.input-values as Strings, or return defaultValue as String if state.input-value is undefined.\n     * @param {string[]|string} keyPath The path of the property to get or set.\n     * @param {any} defaultValue The default value that will be returned if keyPath points to an undefined object.\n     * @returns {string|null|undefined} Returns a string or null, returns undefined if keyPath points to undefined object and defaultValue is undefined.\n     */\n    string: (keyPath, defaultValue) => {\n      return this.input.castString(this.input.get(keyPath), defaultValue)\n    }\n  }\n\n  componentDidMount() {\n    this._unmounted = false\n    // console.log('MountableComponent._unmounted:', this._unmounted)\n  }\n\n  /**\n   * https://reactjs.org/docs/react-component.html#componentwillunmount\n   * componentWillUnmount() is invoked immediately before a component is unmounted and destroyed.\n   * Perform any necessary cleanup in this method, such as invalidating timers,\n   * canceling network requests, or cleaning up any subscriptions that were created in componentDidMount().\n   *\n   * You should not call setState() in componentWillUnmount() because the component will never be re-rendered.\n   * Once a component instance is unmounted, it will never be mounted again.\n   */\n  componentWillUnmount() {\n    this._unmounted = true\n    // console.log('MountableComponent._unmounted:', this._unmounted)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}